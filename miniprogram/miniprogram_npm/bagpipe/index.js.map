{"version":3,"sources":["index.js","lib\\bagpipe.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = require('./lib/bagpipe');\n","var util = require(\"util\");\nvar events = require(\"events\");\n\n/**\n * 构造器，传入限流值，设置异步调用最大并发数\n * Examples:\n * ```\n * var bagpipe = new Bagpipe(100);\n * bagpipe.push(fs.readFile, 'path', 'utf-8', function (err, data) {\n *   // TODO\n * });\n * ```\n * Events:\n * - `full`, 当活动异步达到限制值时，后续异步调用将被暂存于队列中。当队列的长度大于限制值的2倍或100的时候时候，触发`full`事件。事件传递队列长度值。\n * - `outdated`, 超时后的异步调用异常返回。\n * Options:\n * - `disabled`, 禁用限流，测试时用\n * - `refuse`, 拒绝模式，排队超过限制值时，新来的调用将会得到`TooMuchAsyncCallError`异常\n * - `timeout`, 设置异步调用的时间上线，保证异步调用能够恒定的结束，不至于花费太长时间\n * @param {Number} limit 并发数限制值\n * @param {Object} options Options\n */\nvar Bagpipe = function (limit, options) {\n  events.EventEmitter.call(this);\n  this.limit = limit;\n  this.active = 0;\n  this.queue = [];\n  this.options = {\n    disabled: false,\n    refuse: false,\n    ratio: 1,\n    timeout: null\n  };\n  if (typeof options === 'boolean') {\n    options = {\n      disabled: options\n    };\n  }\n  options = options || {};\n  for (var key in this.options) {\n    if (options.hasOwnProperty(key)) {\n      this.options[key] = options[key];\n    }\n  }\n  // queue length\n  this.queueLength = Math.round(this.limit * (this.options.ratio || 1));\n};\nutil.inherits(Bagpipe, events.EventEmitter);\n\n/**\n * 推入方法，参数。最后一个参数为回调函数\n * @param {Function} method 异步方法\n * @param {Mix} args 参数列表，最后一个参数为回调函数。\n */\nBagpipe.prototype.push = function (method) {\n  var args = [].slice.call(arguments, 1);\n  var callback = args[args.length - 1];\n  if (typeof callback !== 'function') {\n    args.push(function () {});\n  }\n  if (this.options.disabled || this.limit < 1) {\n    method.apply(null, args);\n    return this;\n  }\n\n  // 队列长度也超过限制值时\n  if (this.queue.length < this.queueLength || !this.options.refuse) {\n    this.queue.push({\n      method: method,\n      args: args\n    });\n  } else {\n    var err = new Error('Too much async call in queue');\n    err.name = 'TooMuchAsyncCallError';\n    callback(err);\n  }\n\n  if (this.queue.length > 1) {\n    this.emit('full', this.queue.length);\n  }\n\n  this.next();\n  return this;\n};\n\n/*!\n * 继续执行队列中的后续动作\n */\nBagpipe.prototype.next = function () {\n  var that = this;\n  if (that.active < that.limit && that.queue.length) {\n    var req = that.queue.shift();\n    that.run(req.method, req.args);\n  }\n};\n\nBagpipe.prototype._next = function () {\n  this.active--;\n  this.next();\n};\n\n/*!\n * 执行队列中的方法\n */\nBagpipe.prototype.run = function (method, args) {\n  var that = this;\n  that.active++;\n  var callback = args[args.length - 1];\n  var timer = null;\n  var called = false;\n\n  // inject logic\n  args[args.length - 1] = function (err) {\n    // anyway, clear the timer\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    // if timeout, don't execute\n    if (!called) {\n      that._next();\n      callback.apply(null, arguments);\n    } else {\n      // pass the outdated error\n      if (err) {\n        that.emit('outdated', err);\n      }\n    }\n  };\n\n  var timeout = that.options.timeout;\n  if (timeout) {\n    timer = setTimeout(function () {\n      // set called as true\n      called = true;\n      that._next();\n      // pass the exception\n      var err = new Error(timeout + 'ms timeout');\n      err.name = 'BagpipeTimeoutError';\n      err.data = {\n        name: method.name,\n        method: method.toString(),\n        args: args.slice(0, -1)\n      };\n      callback(err);\n    }, timeout);\n  }\n  method.apply(null, args);\n};\n\nmodule.exports = Bagpipe;\n"]}
{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var fs = require('fs');\nvar path = require('path');\nvar cp = require('child_process');\nvar LRU = require('lru-cache');\n\nvar isWin = process.platform === 'win32';\nvar shebangCache = LRU({ max: 50, maxAge: 30 * 1000 });\n\nfunction readShebang(command) {\n    var buffer;\n    var fd;\n    var match;\n    var shebang;\n\n    // Resolve command to an absolute path if it contains /\n    if (command.indexOf(path.sep) !== -1) {\n        command = path.resolve(command);\n    }\n\n    // Check if its resolved in the cache\n    shebang = shebangCache.get(command);\n    if (shebang) {\n        return shebang;\n    }\n\n    // Read the first 150 bytes from the file\n    buffer = new Buffer(150);\n\n    try {\n        fd = fs.openSync(command, 'r');\n        fs.readSync(fd, buffer, 0, 150, 0);\n    } catch (e) {}\n\n    // Check if it is a shebang\n    match = buffer.toString().trim().match(/\\#\\!\\/usr\\/bin\\/env ([^\\r\\n]+)/i);\n    shebang = match && match[1];\n\n    // Store the shebang in the cache\n    shebangCache.set(command, shebang);\n\n    return shebang;\n}\n\nfunction escapeArg(arg, quote) {\n    // Convert to string\n    arg = '' + arg;\n\n    // If we are not going to quote the argument,\n    // escape shell metacharacters, including double and single quotes:\n    if (!quote) {\n        arg = arg.replace(/([\\(\\)%!\\^<>&|;,\"' ])/g, '^$1');\n    } else {\n        // Sequence of backslashes followed by a double quote:\n        // double up all the backslashes and escape the double quote\n        arg = arg.replace(/(\\\\*)\"/gi, '$1$1\\\\\"');\n\n        // Sequence of backslashes followed by the end of the string\n        // (which will become a double quote later):\n        // double up all the backslashes\n        arg = arg.replace(/(\\\\*)$/, '$1$1');\n\n        // All other backslashes occur literally\n\n        // Quote the whole thing:\n        arg = '\"' + arg + '\"';\n    }\n\n    return arg;\n}\n\nfunction escapeCommand(command) {\n    // Do not escape if this command is not dangerous..\n    // We do this so that commands like \"echo\" or \"ifconfig\" work\n    // Quoting them, will make them unnaccessible\n    return /^[a-z0-9_-]+$/i.test(command) ? command : escapeArg(command, true);\n}\n\nfunction spawn(command, args, options) {\n    var applyQuotes;\n    var shebang;\n\n    args = args || [];\n    options = options || {};\n\n    // Use node's spawn if not on windows\n    if (!isWin) {\n        return cp.spawn(command, args, options);\n    }\n\n    // Detect & add support for shebangs\n    shebang = readShebang(command);\n    if (shebang) {\n        args.unshift(command);\n        command = shebang;\n    }\n\n    // Escape command & arguments\n    applyQuotes = command !== 'echo';  // Do not quote arguments for the special \"echo\" command\n    command = escapeCommand(command);\n    args = args.map(function (arg) {\n        return escapeArg(arg, applyQuotes);\n    });\n\n    // Use cmd.exe\n    args = ['/s', '/c', '\"' + command + (args.length ? ' ' + args.join(' ') : '') + '\"'];\n    command = process.env.comspec || 'cmd.exe';\n\n    // Tell node's spawn that the arguments are already escaped\n    options.windowsVerbatimArguments = true;\n\n    return cp.spawn(command, args, options);\n}\n\nmodule.exports = spawn;\nmodule.exports.spawn = spawn;\n"]}